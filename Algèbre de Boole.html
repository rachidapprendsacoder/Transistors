<html lang="fr">
<head>
<meta charset="utf-8" />
<title>  Algèbre de Boole </title>
<link rel="stylesheet" href="style.css">
</head>

<body >
<div style="background-image: url('images algebre de boole/3.jpg');"> 


	<header> <a href="Page d'accueil.html">DOCUMENTATION </a>    <a href = "Editeur.html">EDITEUR BOOLEEN</a>
        </header>
	<table  id="tabl-principale">
            <td id = "hypertext-interface"> 
                <onglet>• Documentation :</onglet>
                <div>&nbsp; <a href="Page d'accueil.html">Accueil</a><br>
                    &nbsp; <a href="Les Transistors.html" >Les Transistors</a><br>
                    &nbsp; <a href="Les portes logiques.html">Portes Logiques</a><br>
                    &nbsp; <a href="Algèbre de Boole.html">Algèbre de Boole</a><br>
                    &nbsp; <a href="Composition d'un ordinateur.html">Les Ordinateurs</a><br><hr>
                </div>
                <onglet>• Editeur Booléen :</onglet>
                <div>&nbsp; <a href = "Editeur.html">Editeur Booléen</a><br>
					&nbsp; <a href = "./index.html">En Détaille</a><br><hr>
                </div>
                
            </td>
			
			<td id="contenu">
<h1>ALGEBRE DE BOOLE</h1>
<div class = "norm1">			
		
<h2>Table de vérité</h2>
L'algèbre de Boole (du nom du mathématicien anglais Georges Boole 1815 - 1864) permet de modéliser des raisonnements logiques, en exprimant l'état de la ou des sorties en fonction d'un certain nombre de paramètres. <br>
La table de vérité d’un circuit caractérise une fonction logique, qui exprime les sorties en fonction des entrées et des trois opérations de base : <br>
<li>AND</li>
<li>OR</li>
<li>NO</li>

Maintenant, voyons comment écrire l'équation d'une table. Dans un premier temps, il est plus simple de s’occuper des sorties à 1, et de ne pas se préoccuper
 des sorties à 0, sauf dans le cas où ces sorties sont moins fréquentes que les entrées à 1. <br>
L’expression de la sortie sera une somme de produit, avec le nombre de termes égal à celui des sorties qui valent 1, et le nombre des facteurs de chaque terme
 égal au nombre d'entrées.<br>
On exprime donc chacune des entrées de formes génériques : si elle vaut 0 alors elle est barrée, si elle vaut 1 on la garde telle quelle.  

<table class = "verite">

	<thead>
		<th>__A__</th>
		<th>__B__</th>
		<th>__S__</th>
	</thead>
	<tbody>
	<tr>
		<td><span style="background-color: #FF0000;">0</span></td>
		<td><span style="background-color: #FF0000;">0</span></td>
		<td><span style="background-color: #FF0000;">0</span></td>
	</tr>
	<tr>
		<td><span style="background-color: #008000;">0</span<</td>
		<td><span style="background-color: #008000;">1</span></td>
		<td><span style="background-color: #008000;">1</span></td>
	</tr>
	<tr>
		<td><span style="background-color: #008000;">1</span></td>
		<td><span style="background-color: #008000;">0</span></td>
		<td><span style="background-color: #008000;">1</span></td>
	</tr>
	<tr>
		<td><span style="background-color: #FF0000;">1</span></td>
		<td><span style="background-color: #FF0000;">1</span></td>
		<td><span style="background-color: #FF0000;">0</span></td>
	</tr>
	</tbody>
</table> <br>

<alg>
 <y>S=</y>
 <n>A</n>
 <y>B</y>
 <y>+</y>
 <y>A</y>
 <n>B</n>  
</alg>
<br>
On utilise ensuite les lois de composition liées à l'algèbre de Boole, (associativité, commutativité, lois de de Morgan, etc), pour simplifier l'expression de S : <br>
<alg>
S = A <xor>⊕</xor> B <br>
</alg>

Il s’agit donc d’une porte XOR.<br>
Voici la table de vérité d’un additionneur 2 bits :<bR>
<table class = "verite">
	
	<thead>
		<th>__A__</th>
		<th>__B__</th>
		<th>__Ci__</th>
		<th>__S__</th>
		<th>__Ci+1__</th>
	</thead>
	<tbody>
	<tr>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
	</tr>
	<tr>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>1</td>
		<td>0</td>
		
	</tr>
	<tr>
		<td>0</td>
		<td>1</td>
		<td>0</td>
		<td>1</td>
		<td>0</td>
	</tr>
	<tr>
		<td>0</td>
		<td>1</td>
		<td>1</td>
		<td>0</td>
		<td>1</td>
	</tr>
	</tr>
	<tr>
		
		<td>1</td>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>0</td>
	</tr>
	<tr>
		<td>1</td>
		<td>0</td>
		<td>1</td>
		<td>0</td>
		<td>1</td>
	</tr>
	<tr>
		<td>1</td>
		<td>1</td>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		
	</tr>
	<tr>
		<td>1</td>
		<td>1</td>
		<td>1</td>
		<td>1</td>
		<td>1</td>
	</tr>
	</tbody>
</table> 
On exprime les sorties en fonction des entrées comme vu précédemment.<br>

<br>
<alg>
	<y>S=</y>
	<n>A</n>
    <y>×</y>
    <n>B</n>
    <y>×Ci+</y>
    <n>A</n>
    <y>×</y>
    <y>B×</y>
    <n>Ci</n>
    <y>+A×</y>
    <n>B</n>
    <y>×</y>
    <n>Ci</n>
   <y>+A×B×Ci</y>
</alg>
<alg>

<y>=</y>
<y>(</y>
<n>A</n>
<y>×</y>
 <n>B</n>
 <y>+A×B)×Ci</y>
   <y>+</y>
   <y>(</y>
   <y>A</y>
<y>×</y>
<n>B</n>
<y>+</y>
<n>A</n>
 <y>×B)</y>
 <y>×</y>
 <n>Ci</n></alg>
 <alg>
<y>=</y>
<y>A</y>
<y><xor>⊕</xor></y>
<y>B</y>
<y><xor>⊕</xor></y>
<y>Ci</y>
</alg>
<br>
<alg>
<y>Ci+1=</y>
<y>A</y>
<y>×</y>
<y>B</y>
 <y>×</y>
 <n>Ci</n>
<y>+A</y>
<y>×</y>
 <n>B</n>
<y>×</y>
 <y>Ci+</y>
 
 <n>A</n>
 <y>×B×Ci+A×B×Ci</y>
 
</alg>
<alg>
<y>=A×B+</y>
<y>(</y>
<n>A</n>
 <y>×B+A</y>
 <n>B</n>
 <y>)×Ci</y>
</alg>
<alg>
<y>=A×B+</y>
<y>(A<xor>⊕</xor>B)×Ci</y>
</alg><br>

On modélise enfin la fonction à l'aide d'un circuit, le passage entre l'un et l'autre étant encore une fois fait de façon logique.
<img src="images algebre de boole/circuit.jpeg" alt="circuit !"> <br>
Une fois qu'on a un additionneur deux bits, on peut en faire succéder d'avantages et ainsi obtenir un additionneur pouvant avoir en entrée beaucoup plus de bits.<br>
<img src="images algebre de boole/add8bit.jpg" style="width: 60%"><br><br>
<img src="images algebre de boole/maincirc.jpg" style="width: 60%">

</div>
<div class = "norm2">
<h2>Tableau de Karnaugh</h2>
Le tableau de Karnaugh est une autre version de la  table de vérité, la différence étant  l'agencement des 0 et des 1 et également la taille du tableau. En effet,
 un tableau de Karnaugh est plus pratique qu'une table de vérité car est à double entrée. Verticalement nous avons les combinaisons possibles pour une, deux, trois 
 ou même plus d'entrées, idem horizontalement. L'ordre des combinaisons possibles est fait de telle sorte à ce que d'une colonne à l'autre il n'y ait qu'un changement d'entrée. Voyons un petit exemple :
 <table class = "verite">
	<thead>
		<th>__A__</th>
		<th>__B__</th>
		<th>__C__</th>
		<th>__D__</th>
		<th>__S__</th>
	</thead>
	<tbody>
	<tr>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
	</tr>
	<tr>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>0</td>
		
	</tr>
	<tr>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>0</td>
		<td>0</td>
	</tr>
	<tr>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>1</td>
		<td>1</td>
	</tr>
	</tr>
	<tr>
		
		<td>0</td>
		<td>1</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
	</tr>
	<tr>
		<td>0</td>
		<td>1</td>
		<td>0</td>
		<td>1</td>
		<td>1</td>
	</tr>
	<tr>
		<td>0</td>
		<td>1</td>
		<td>1</td>
		<td>0</td>
		<td>0</td>
		
	</tr>
	<tr>
		<td>0</td>
		<td>1</td>
		<td>1</td>
		<td>1</td>
		<td>1</td>
	</tr>
	
	<tr>
		<td>1</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
	</tr>
	<tr>
		<td>1</td>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>0</td>
		
	</tr>
	<tr>
		<td>1</td>
		<td>0</td>
		<td>1</td>
		<td>0</td>
		<td>0</td>
	</tr>
	<tr>
		<td>1</td>
		<td>0</td>
		<td>1</td>
		<td>1</td>
		<td>1</td>
	</tr>
	<tr>
		<td>1</td>
		<td>1</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		
	</tr>
	<tr>
		<td>1</td>
		<td>1</td>
		<td>0</td>
		<td>1</td>
		<td>1</td>
	</tr>
	<tr>
		<td>1</td>
		<td>1</td>
		<td>1</td>
		<td>0</td>
		<td>0</td>
		
	</tr>
	<tr>
		<td>1</td>
		<td>1</td>
		<td>1</td>
		<td>1</td>
		<td>1</td>
	</tr>
	</tbody>
</table> 





 On remarque que cette table est plutôt longue, alors on la transforme en un tableau de Karnaugh. Horizontalement, on a les combinaisons AB, et verticalement les combinaisons CD, avec dans le tableau les résultats en sortie.
 <table class = "verite">
	<thead>
		<th>AB/CD</th>
		<th>00</th>
		<th>01</th>
		<th>11</th>
		<th>10</th>
	</thead>
	<tbody>
	<tr>
		<td>00</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		
	</tr>
	<tr>
		<td>01</td>
		<td>0</td>
		<td>1</td>
		<td>1</td>
		<td>0</td>
	</tr>
	<tr>
		<td>11</td>
		<td>1</td>
		<td>1</td>
		<td>1</td>
		<td>1</td>
		
	</tr>
	<tr>
		<td>10</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
	</tr>
	</tbody>
</table>
 
 Maintenant que nous avons notre tableau de Karnaugh, nous pouvons encore retrouver l'équation du circuit. Pour cela on regroupe les sorties à 1 par paquet de puissance de 2. (colorier les 4 1 en carrée du milie, et les 4 1 en ligne d'une couleur différentes) 
  <table class = "verite">
 	<thead>
		<th>AB/CD</th>
		<th>00</th>
		<th>01</th>
		<th>11</th>
		<td>10</th>
	</thead>
	<tbody>
	<tr>
		<td>00</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		
	</tr>
	<tr>
		<td>01</td>
		<td>0</td>
		<td><span style="background-color: #008000;">1</span></td>
		<td><span style="background-color: #008000;">1</span></td>
		<td>0</td>
	</tr>
	<tr>
		<td>11</td>
		<td>1</td>
		<td>1</td>
		<td>1</td>
		<td>1</td>
		
	</tr>
	<tr>
		<td>10</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
	</tr>
	</tbody>
</table>
S sera égale à une somme, cette fois en fonction des paquets qu'on a réalisés. Intéressons nous au 1er paquet d'un point de vue horizontal. On voit que l'entrée A passe de 0 à 1 (01 --> 11). On ne tient donc plus compte de A. B reste à 1, et donc on retient B. Maintenant, regardons ce même paquet d'un point de vue vertical. On voit que l'entrée C varie (01 --> 11) et l'entrée D reste la même (à 1). On a notre premier terme, qui est le produit de ce que nous avons retenu horizontalement et verticalement. Donc pour l'instant S = BD.  <br>
Allons voir le second paquet. D'un point de vue horizontal les deux entrées A et B varient, donc on en tient pas compte. Par contre, verticalement, C et D restent dans les mêmes états (11). Donc on écrit S = BD + CD. 

</div>
</td>
</table>
<footer>
    <div><a href="Les portes logiques.html">↤Page Précédente </a></div>
    <div><a href="Composition d'un ordinateur.html">Page Suivante↦</a></div>
    </footer>
</body>
</html>
